#!/bin/bash
# üåü Nettoyage Complet du Projet Athalia - VERSION OPTIMIS√âE
# Version 5.1 - Nettoyage complet + Arr√™t des processus Athalia

set -euo pipefail

# =============================================================================
# SECTION 1: CONFIGURATION RAPIDE
# =============================================================================

# Couleurs simplifi√©es
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Variables optimis√©es
CLEANED_COUNT=0
DRY_RUN_MODE=false
KILL_PROCESSES=false
FORCE_APPLEDOUBLE=false

# D√©tection des options
for arg in "$@"; do
    case $arg in
        --dry-run|-d)
            DRY_RUN_MODE=true
            ;;
        --kill-processes|-k)
            KILL_PROCESSES=true
            ;;
        --force-appledouble|-f)
            FORCE_APPLEDOUBLE=true
            ;;
        --help|-h)
            echo "Usage: ath-clean [OPTIONS]"
            echo "Options:"
            echo "  --dry-run, -d     Mode simulation (ne supprime rien)"
            echo "  --kill-processes, -k  Arr√™te tous les processus Athalia"
            echo "  --force-appledouble, -f  Force la suppression des fichiers AppleDouble"
            echo "  --help, -h        Affiche cette aide"
            exit 0
            ;;
    esac
done

# =============================================================================
# SECTION 2: FONCTIONS D'AFFICHAGE OPTIMIS√âES
# =============================================================================

print_header() {
    echo -e "${BLUE}üöÄ Nettoyage Complet Athalia${NC}"
    echo
}

print_section() {
    echo -e "${BLUE}üìã $1${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_summary() {
    echo
    echo -e "${GREEN}üéØ Total nettoy√© : $CLEANED_COUNT √©l√©ments${NC}"
    echo
}

# =============================================================================
# SECTION 3: FONCTIONS DE GESTION DES PROCESSUS
# =============================================================================

# Fonction pour arr√™ter tous les processus Athalia
kill_athalia_processes() {
    print_section "Arr√™t des processus Athalia"
    
    # Patterns pour identifier les processus Athalia
    local patterns=(
        "athalia_core"
        "athalia_unified"
        "ath-"
        "pytest.*athalia"
        "python.*athalia"
        "python3.*athalia"
    )
    
    local killed_count=0
    
    for pattern in "${patterns[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            # Mode simulation - afficher les processus qui seraient arr√™t√©s
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${YELLOW}   [DRY-RUN] Processus qui seraient arr√™t√©s avec pattern '$pattern':${NC}"
                echo "$processes" | while read line; do
                    echo -e "${YELLOW}   [DRY-RUN] $line${NC}"
                done
                local count=$(echo "$processes" | wc -l)
                killed_count=$((killed_count + count))
            fi
        else
            # Mode r√©el - arr√™ter les processus
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${BLUE}   Arr√™t des processus avec pattern '$pattern'...${NC}"
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -TERM "$pid" 2>/dev/null; then
                            print_success "Arr√™t√© PID $pid: $cmd"
                            killed_count=$((killed_count + 1))
                        else
                            print_warning "Impossible d'arr√™ter PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        fi
    done
    
    # Attendre un peu pour les processus qui se terminent proprement
    if [ "$DRY_RUN_MODE" = false ] && [ $killed_count -gt 0 ]; then
        print_info "Attente de 3 secondes pour la terminaison propre..."
        sleep 3
        
        # Forcer l'arr√™t des processus qui n'ont pas r√©pondu au SIGTERM
        for pattern in "${patterns[@]}"; do
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -KILL "$pid" 2>/dev/null; then
                            print_warning "Forc√© l'arr√™t PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        done
    fi
    
    if [ $killed_count -gt 0 ]; then
        print_success "Total: $killed_count processus Athalia arr√™t√©s"
    else
        print_info "Aucun processus Athalia trouv√©"
    fi
    
    echo
}

# =============================================================================
# SECTION 4: FONCTIONS DE NETTOYAGE COMPLETES
# =============================================================================

# Fonction de nettoyage rapide avec patterns multiples
fast_clean() {
    local patterns=("$@")
    local description="${patterns[0]}"
    shift
    local pattern_list=("$@")
    
    echo -e "${BLUE}üîç $description...${NC}"
    
    local total_count=0
    
    for pattern in "${pattern_list[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | wc -l)
            if [ $count -gt 0 ]; then
                echo -e "${YELLOW}   [DRY-RUN] $count fichiers trouv√©s avec pattern: $pattern${NC}"
                total_count=$((total_count + count))
            fi
        else
            local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -delete 2>/dev/null | wc -l)
            if [ $count -gt 0 ]; then
                print_success "$count √©l√©ments nettoy√©s avec pattern: $pattern"
                total_count=$((total_count + count))
            fi
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
}

# Fonction de nettoyage des dossiers cache
clean_cache_directories() {
    local dirs=("$@")
    local description="$1"
    
    echo -e "${BLUE}üóÇÔ∏è  $description...${NC}"
    
    local total_count=0
    
    for dir in "${dirs[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                echo -e "${YELLOW}   [DRY-RUN] Dossier trouv√©: $dir ($size)${NC}"
                total_count=$((total_count + 1))
            fi
        else
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                rm -rf "$dir" 2>/dev/null
                print_success "Dossier supprim√©: $dir ($size)"
                total_count=$((total_count + 1))
            fi
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
}

# =============================================================================
# SECTION 5: FONCTIONS DE PR√âVENTION
# =============================================================================

# Fonction pour d√©sactiver la cr√©ation de fichiers AppleDouble
disable_appledouble_creation() {
    print_section "D√©sactivation de la cr√©ation de fichiers AppleDouble"
    
    if [ "$DRY_RUN_MODE" = true ]; then
        echo -e "${YELLOW}   [DRY-RUN] V√©rification de la configuration AppleDouble...${NC}"
        if defaults read com.apple.desktopservices DSDontWriteNetworkStores 2>/dev/null | grep -q "1"; then
            echo -e "${YELLOW}   [DRY-RUN] Configuration AppleDouble d√©j√† d√©sactiv√©e${NC}"
        else
            echo -e "${YELLOW}   [DRY-RUN] Configuration AppleDouble √† d√©sactiver${NC}"
        fi
    else
        # D√©sactiver la cr√©ation de fichiers AppleDouble sur les volumes r√©seau
        if defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true 2>/dev/null; then
            print_success "Cr√©ation de fichiers AppleDouble d√©sactiv√©e sur les volumes r√©seau"
        else
            print_warning "Impossible de d√©sactiver la cr√©ation de fichiers AppleDouble (droits insuffisants)"
        fi
        
        # D√©sactiver la cr√©ation de fichiers AppleDouble localement
        if defaults write com.apple.desktopservices DSDontWriteUSBStores -bool true 2>/dev/null; then
            print_success "Cr√©ation de fichiers AppleDouble d√©sactiv√©e sur les volumes USB"
        else
            print_warning "Impossible de d√©sactiver la cr√©ation de fichiers AppleDouble USB (droits insuffisants)"
        fi
        
        # Red√©marrer Finder pour appliquer les changements
        if killall Finder 2>/dev/null; then
            print_info "Finder red√©marr√© pour appliquer les changements"
        fi
    fi
    
    echo
}

# =============================================================================
# SECTION 6: EX√âCUTION PRINCIPALE COMPL√àTE
# =============================================================================

# Affichage de l'en-t√™te
print_header

# D√©sactivation de la cr√©ation de fichiers AppleDouble
disable_appledouble_creation

# Arr√™t des processus Athalia si demand√©
if [ "$KILL_PROCESSES" = true ]; then
    kill_athalia_processes
fi

# Nettoyage complet des fichiers AppleDouble et macOS
print_section "Nettoyage des fichiers AppleDouble et macOS"
fast_clean "Fichiers syst√®me macOS" "._*" ".DS_Store" ".!*" "*.noindex" "Thumbs.db" "desktop.ini"

# Nettoyage sp√©cifique des fichiers AppleDouble (.DS_Store et ._*)
print_section "Nettoyage sp√©cifique des fichiers AppleDouble"
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}   [DRY-RUN] Recherche de fichiers AppleDouble...${NC}"
    find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | while read file; do
        echo -e "${YELLOW}   [DRY-RUN] Fichier AppleDouble trouv√©: $file${NC}"
    done
    find . -name ".DS_Store" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | while read file; do
        echo -e "${YELLOW}   [DRY-RUN] Fichier .DS_Store trouv√©: $file${NC}"
    done
else
    # Compter d'abord les fichiers AppleDouble
    apple_double_count=$(find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | wc -l)
    if [ $apple_double_count -gt 0 ]; then
        # Supprimer les fichiers AppleDouble
        find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -delete 2>/dev/null
        print_success "$apple_double_count fichiers AppleDouble (._*) supprim√©s"
        CLEANED_COUNT=$((CLEANED_COUNT + apple_double_count))
    fi
    
    # Compter d'abord les fichiers .DS_Store
    ds_store_count=$(find . -name ".DS_Store" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | wc -l)
    if [ $ds_store_count -gt 0 ]; then
        # Supprimer les fichiers .DS_Store
        find . -name ".DS_Store" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -delete 2>/dev/null
        print_success "$ds_store_count fichiers .DS_Store supprim√©s"
        CLEANED_COUNT=$((CLEANED_COUNT + ds_store_count))
    fi
fi

# Nettoyage sp√©cifique des fichiers AppleDouble dans athalia_core
print_section "Nettoyage sp√©cifique des fichiers AppleDouble dans athalia_core"
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}   [DRY-RUN] Recherche de fichiers AppleDouble dans athalia_core...${NC}"
    if [ -d "./athalia_core" ]; then
        find ./athalia_core -name "._*" 2>/dev/null | while read file; do
            echo -e "${YELLOW}   [DRY-RUN] Fichier AppleDouble trouv√© dans athalia_core: $file${NC}"
        done
    fi
else
    if [ -d "./athalia_core" ]; then
        # Compter d'abord les fichiers AppleDouble dans athalia_core
        core_apple_double_count=$(find ./athalia_core -name "._*" 2>/dev/null | wc -l)
        if [ $core_apple_double_count -gt 0 ]; then
            # Supprimer les fichiers AppleDouble dans athalia_core
            find ./athalia_core -name "._*" -delete 2>/dev/null
            print_success "$core_apple_double_count fichiers AppleDouble supprim√©s dans athalia_core"
            CLEANED_COUNT=$((CLEANED_COUNT + core_apple_double_count))
            
            # Si l'option force est activ√©e, supprimer √† nouveau apr√®s un d√©lai
            if [ "$FORCE_APPLEDOUBLE" = true ]; then
                print_info "Attente de 2 secondes pour la suppression forc√©e..."
                sleep 2
                force_count=$(find ./athalia_core -name "._*" 2>/dev/null | wc -l)
                if [ $force_count -gt 0 ]; then
                    find ./athalia_core -name "._*" -delete 2>/dev/null
                    print_success "$force_count fichiers AppleDouble supprim√©s en mode forc√©"
                    CLEANED_COUNT=$((CLEANED_COUNT + force_count))
                fi
            fi
        else
            print_info "Aucun fichier AppleDouble trouv√© dans athalia_core"
        fi
    fi
fi

# Nettoyage complet des fichiers Python compil√©s
print_section "Nettoyage des fichiers Python compil√©s"
fast_clean "Fichiers Python compil√©s" "*.pyc" "*.pyo" "*.pyd" "__pycache__" "*.so" "*.dll" "*.dylib"

# Nettoyage complet des caches de tests et outils
print_section "Nettoyage des caches de tests et outils"
fast_clean "Caches de tests" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "coverage.xml" "htmlcov" ".tox" ".cache"

# Nettoyage complet des fichiers de couverture
print_section "Nettoyage des fichiers de couverture"
fast_clean "Fichiers de couverture" "*.coverage" "coverage.xml" "htmlcov" ".coverage.*" "coverage_html" "cov.xml"

# Nettoyage complet des fichiers temporaires
print_section "Nettoyage des fichiers temporaires"
fast_clean "Fichiers temporaires" "*.tmp" "*.temp" "*.swp" "*.swo" "*~" "*.bak" "*.backup" "*.orig"

# Nettoyage complet des fichiers de build
print_section "Nettoyage des fichiers de build"
fast_clean "Fichiers de build" "build" "dist" "*.egg-info" "*.egg" "__pycache__" "*.pyc" "*.pyo"

# Nettoyage complet des fichiers de logs
print_section "Nettoyage des fichiers de logs"
fast_clean "Fichiers de logs" "*.log" "logs" "*.out" "*.err" "debug.log" "error.log"

# Nettoyage complet des fichiers de donn√©es temporaires
print_section "Nettoyage des fichiers de donn√©es temporaires"
fast_clean "Fichiers de donn√©es temporaires" "*.db" "*.sqlite" "*.sqlite3" "*.cache" "*.dat" "*.tmp"

# Nettoyage complet des fichiers corrompus
print_section "Nettoyage des fichiers corrompus"
fast_clean "Fichiers corrompus" "*.f(f)" "*.corrupt" "*.broken"

# Nettoyage des dossiers cache sp√©cifiques
print_section "Nettoyage des dossiers cache sp√©cifiques"
clean_cache_directories "Dossiers cache" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "htmlcov" ".tox" ".cache" "build" "dist" "*.egg-info" "__pycache__"

# Nettoyage des caract√®res null des fichiers Python
print_section "Nettoyage des caract√®res null"
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}   [DRY-RUN] Recherche de fichiers avec caract√®res null${NC}"
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        echo -e "${YELLOW}   [DRY-RUN] Fichier avec caract√®res null: $file${NC}"
    done
else
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        if [ -f "$file" ]; then
            tr -d '\000' < "$file" > "$file.tmp" 2>/dev/null && mv "$file.tmp" "$file" 2>/dev/null
            print_success "Nettoy√©: $file"
            CLEANED_COUNT=$((CLEANED_COUNT + 1))
        fi
    done
fi

# Nettoyage des fichiers de configuration temporaires
print_section "Nettoyage des fichiers de configuration temporaires"
fast_clean "Fichiers de configuration temporaires" "*.cfg.tmp" "*.ini.tmp" "*.yaml.tmp" "*.yml.tmp" "*.json.tmp"

# Nettoyage des fichiers de documentation temporaires
print_section "Nettoyage des fichiers de documentation temporaires"
fast_clean "Fichiers de documentation temporaires" "*.md.tmp" "*.rst.tmp" "*.txt.tmp" "docs/_build" "docs/build"

# Nettoyage des fichiers de IDE/√©diteurs
print_section "Nettoyage des fichiers d'√©diteurs"
fast_clean "Fichiers d'√©diteurs" ".vscode/settings.json.tmp" ".idea/workspace.xml.tmp" "*.sublime-*" ".editorconfig.tmp"

# Affichage du r√©sum√©
print_summary 
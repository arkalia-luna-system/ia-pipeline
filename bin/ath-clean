#!/bin/bash
# üåü Nettoyage Complet du Projet Athalia/Arkalia - VERSION ULTRA-S√âCURIS√âE
# Version 3.0 - Interface stylis√©e avec couleurs et organisation modulaire
# Protection maximale contre la suppression accidentelle

set -euo pipefail  # Mode strict - arr√™t sur erreur

# =============================================================================
# SECTION 1: CONFIGURATION ET COULEURS
# =============================================================================

# Couleurs pour l'interface
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Variables de s√©curit√©
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
CLEANED_FILES=0
CLEANED_DIRS=0
CLEANED_PROCESSES=0
DRY_RUN_MODE=false

# D√©tection du mode dry-run
if [ "${1:-}" = "--dry-run" ] || [ "${1:-}" = "-d" ]; then
    DRY_RUN_MODE=true
fi

# =============================================================================
# SECTION 2: FONCTIONS D'AFFICHAGE ET UI
# =============================================================================

print_header() {
    echo -e "${BOLD}${CYAN}üîí Nettoyage Athalia/Arkalia - MODE S√âCURIS√â${NC}"
    echo -e "${CYAN}==============================================${NC}"
    echo
}

print_section() {
    local title="$1"
    echo -e "${BOLD}${PURPLE}üìã $title${NC}"
    echo -e "${PURPLE}--------------------------------${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}üö® $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_clean() {
    echo -e "${GREEN}üóëÔ∏è  $1${NC}"
}

print_dry_run() {
    echo -e "${YELLOW}üîç [DRY-RUN] $1${NC}"
}

print_summary() {
    echo
    echo -e "${BOLD}${CYAN}üéØ R√©sum√© du nettoyage :${NC}"
    echo -e "${WHITE}   üìä Total d'√©l√©ments nettoy√©s : ${GREEN}$CLEANED_FILES${NC}"
    echo -e "${WHITE}   üìÅ Dossiers nettoy√©s : ${GREEN}$CLEANED_DIRS${NC}"
    echo -e "${WHITE}   üîÑ Processus arr√™t√©s : ${GREEN}$CLEANED_PROCESSES${NC}"
    echo
    echo -e "${BOLD}${GREEN}üõ°Ô∏è  S√©curit√© :${NC}"
    echo -e "${WHITE}   ‚úÖ Tous les fichiers critiques ont √©t√© pr√©serv√©s${NC}"
    echo -e "${WHITE}   ‚úÖ Aucun fichier syst√®me n'a √©t√© touch√©${NC}"
    echo -e "${WHITE}   ‚úÖ V√©rifications de s√©curit√© activ√©es${NC}"
    echo
}

print_footer() {
    if [ "$DRY_RUN_MODE" = true ]; then
        echo -e "${YELLOW}üîç MODE DRY-RUN - Aucun fichier n'a √©t√© supprim√©${NC}"
    else
        echo -e "${GREEN}‚úÖ Nettoyage termin√© ! Le projet Athalia/Arkalia est maintenant propre et optimis√©.${NC}"
    fi
    echo
    echo -e "${BOLD}${CYAN}üí° Conseils :${NC}"
    echo -e "${WHITE}   - Ex√©cutez 'ath-clean --dry-run' pour tester sans supprimer${NC}"
    echo -e "${WHITE}   - Utilisez 'ark-process-check.sh' pour surveiller les processus${NC}"
    echo -e "${WHITE}   - Les fichiers critiques sont automatiquement pr√©serv√©s${NC}"
    echo -e "${WHITE}   - La configuration a √©t√© optimis√©e pour les performances${NC}"
    echo
    echo -e "${BOLD}${GREEN}üöÄ Pour red√©marrer proprement :${NC}"
    echo -e "${WHITE}   python3 -m athalia_core.main${NC}"
}

# =============================================================================
# SECTION 3: S√âCURIT√â ET V√âRIFICATIONS
# =============================================================================

# LISTE DES FICHIERS/DOSSIERS CRITIQUES - JAMAIS SUPPRIM√âS
CRITICAL_PATHS=(
    ".git"
    ".venv"
    "venv"
    "env"
    "node_modules"
    "data"
    "config"
    "docs"
    "tests"
    "athalia_core"
    "bin"
    "scripts"
    "setup"
    "tools"
    "plugins"
    "templates"
    "prompts"
    "blueprints_history"
    "backups"
    "logs"
    "archive"
    "*.py"
    "*.md"
    "*.yaml"
    "*.yml"
    "*.json"
    "*.toml"
    "*.cfg"
    "*.ini"
    "*.sh"
    "*.txt"
    "*.rst"
    "*.html"
    "*.css"
    "*.js"
    "*.ts"
    "*.vue"
    "*.jsx"
    "*.tsx"
    "*.sql"
    "*.db"
    "*.sqlite"
    "*.sqlite3"
    "*.log"
    "*.lock"
    "requirements.txt"
    "setup.py"
    "pyproject.toml"
    "Cargo.toml"
    "package.json"
    "composer.json"
    "Gemfile"
    "Dockerfile"
    "docker-compose.yml"
    "Makefile"
    "README*"
    "CHANGELOG*"
    "LICENSE*"
    "ROADMAP*"
    "CONTRIBUTING*"
    "CODE_OF_CONDUCT*"
    ".gitignore"
    ".gitattributes"
    ".editorconfig"
    ".eslintrc*"
    ".prettierrc*"
    ".babelrc*"
    ".env*"
    ".dockerignore"
    ".npmrc"
    ".yarnrc"
    ".bowerrc"
    ".jshintrc"
    ".jscsrc"
    ".stylelintrc*"
    ".browserslistrc"
    ".babelrc*"
    ".postcssrc*"
    ".eslintignore"
    ".prettierignore"
    ".stylelintignore"
    ".flowconfig"
    ".flowconfig.js"
    ".flowconfig.json"
    ".babelrc.js"
    ".babelrc.json"
    ".postcssrc.js"
    ".postcssrc.json"
    ".eslintrc.js"
    ".eslintrc.json"
    ".prettierrc.js"
    ".prettierrc.json"
    ".stylelintrc.js"
    ".stylelintrc.json"
    ".jshintrc.js"
    ".jshintrc.json"
    ".jscsrc.js"
    ".jscsrc.json"
    ".browserslistrc.js"
    ".browserslistrc.json"
    ".babelrc.js"
    ".babelrc.json"
    ".postcssrc.js"
    ".postcssrc.json"
    ".eslintrc.js"
    ".eslintrc.json"
    ".prettierrc.js"
    ".prettierrc.json"
    ".stylelintrc.js"
    ".stylelintrc.json"
    ".jshintrc.js"
    ".jshintrc.json"
    ".jscsrc.js"
    ".jscsrc.json"
    ".browserslistrc.js"
    ".browserslistrc.json"
)

# Fonction de v√©rification de s√©curit√©
is_critical_path() {
    local path="$1"
    
    # Exception sp√©ciale : les fichiers ._* (AppleDouble) ne sont jamais critiques
    # Sauf s'ils sont dans des dossiers vraiment critiques
    if [[ "$path" == *"/._"* ]] || [[ "$path" == "._"* ]]; then
        # Permettre la suppression des ._* m√™me dans les caches
        if [[ "$path" == *"/.mypy_cache/"* ]] || [[ "$path" == *"/__pycache__/"* ]] || [[ "$path" == *"/.pytest_cache/"* ]]; then
            return 1  # Non critique - peut √™tre supprim√©
        fi
        # Pour les autres dossiers, v√©rifier s'ils sont vraiment critiques
        for critical in "${CRITICAL_PATHS[@]}"; do
            if [[ "$path" == *"$critical"* ]] || [[ "$path" == "$critical" ]]; then
                # Exception : permettre ._* dans les caches m√™me s'ils sont dans des dossiers critiques
                if [[ "$critical" == ".mypy_cache" ]] || [[ "$critical" == "__pycache__" ]] || [[ "$critical" == ".pytest_cache" ]]; then
                    return 1  # Non critique - peut √™tre supprim√©
                fi
                return 0  # Critique - ne pas supprimer
            fi
        done
        return 1  # Non critique - peut √™tre supprim√©
    fi
    
    for critical in "${CRITICAL_PATHS[@]}"; do
        if [[ "$path" == *"$critical"* ]] || [[ "$path" == "$critical" ]]; then
            return 0  # Critique - ne pas supprimer
        fi
    done
    return 1  # Non critique - peut √™tre supprim√©
}

# Fonction de v√©rification de s√©curit√© renforc√©e
is_safe_to_delete() {
    local path="$1"
    
    # V√©rifications de s√©curit√©
    if [[ "$path" == "/" ]] || [[ "$path" == "/home" ]] || [[ "$path" == "/Users" ]]; then
        print_error "Tentative de suppression d'un r√©pertoire syst√®me critique: $path"
        return 1
    fi
    
    if [[ "$path" == *".."* ]]; then
        print_error "Chemin suspect d√©tect√©: $path"
        return 1
    fi
    
    if [[ "$path" == *"/"* ]] && [[ ! "$path" =~ ^\./ ]]; then
        print_error "Chemin absolu d√©tect√©: $path"
        return 1
    fi
    
    if is_critical_path "$path"; then
        print_warning "Fichier critique pr√©serv√©: $path"
        return 1
    fi
    
    return 0
}

# =============================================================================
# SECTION 4: FONCTIONS DE NETTOYAGE
# =============================================================================

# Fonction pour compter les fichiers supprim√©s
count_cleaned() {
    local count=$1
    if [ $count -gt 0 ]; then
        print_success "$count √©l√©ments nettoy√©s"
        CLEANED_FILES=$((CLEANED_FILES + count))
    fi
}

# Fonction de nettoyage s√©curis√©
safe_delete() {
    local pattern="$1"
    local description="$2"
    local dry_run=${3:-false}
    
    echo -e "${BLUE}üîç $description...${NC}"
    
    if [ "$dry_run" = true ]; then
        print_dry_run "Recherche de fichiers: $pattern"
        local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
        echo -e "${WHITE}   üìä [DRY-RUN] $count fichiers trouv√©s${NC}"
        return
    fi
    
    local count=0
    while IFS= read -r -d '' file; do
        if is_safe_to_delete "$file"; then
            if rm -f "$file" 2>/dev/null; then
                count=$((count + 1))
                print_clean "Supprim√©: $file"
            fi
        fi
    done < <(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    
    count_cleaned $count
}

# Fonction de nettoyage de dossiers s√©curis√©
safe_delete_dir() {
    local pattern="$1"
    local description="$2"
    local dry_run=${3:-false}
    
    echo -e "${BLUE}üîç $description...${NC}"
    
    if [ "$dry_run" = true ]; then
        print_dry_run "Recherche de dossiers: $pattern"
        local count=$(find . -path "$pattern" -type d -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
        echo -e "${WHITE}   üìä [DRY-RUN] $count dossiers trouv√©s${NC}"
        return
    fi
    
    local count=0
    while IFS= read -r -d '' dir; do
        if is_safe_to_delete "$dir"; then
            if rm -rf "$dir" 2>/dev/null; then
                count=$((count + 1))
                print_clean "Supprim√©: $dir"
            fi
        fi
    done < <(find . -path "$pattern" -type d -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    
    count_cleaned $count
}

# Fonction pour g√©rer les processus
manage_processes() {
    print_section "Analyse des processus Athalia"
    
    # V√©rifier les processus Python athalia_core
    ATHALIA_PROCESSES=$(ps aux | grep -c "[a]thalia_core.main" 2>/dev/null || echo "0")
    if [ "$ATHALIA_PROCESSES" -gt 0 ] 2>/dev/null; then
        print_warning "$ATHALIA_PROCESSES processus Athalia d√©tect√©s"
        print_info "Utilisez 'ark-process-check.sh' pour les g√©rer"
        
        if [ "$DRY_RUN_MODE" != true ]; then
            read -p "   Voulez-vous arr√™ter les processus Athalia ? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${YELLOW}   üî™ Arr√™t des processus Athalia...${NC}"
                pkill -f "athalia_core.main" 2>/dev/null
                CLEANED_PROCESSES=$ATHALIA_PROCESSES
                print_success "$ATHALIA_PROCESSES processus arr√™t√©s"
            fi
        fi
    else
        print_success "Aucun processus Athalia en cours"
    fi
}

# Fonction pour nettoyer les caract√®res null de mani√®re s√©curis√©e
clean_null_bytes_safe() {
    print_section "Nettoyage des caract√®res null (corruption de fichiers)"
    
    local count=0
    
    # Nettoyer uniquement les fichiers Python du projet principal
    echo -e "${BLUE}   üîç Recherche de fichiers Python avec caract√®res null...${NC}"
    
    while IFS= read -r -d '' file; do
        if [ -f "$file" ] && [ -r "$file" ]; then
            if grep -q $'\x00' "$file" 2>/dev/null; then
                if [ "$DRY_RUN_MODE" = "true" ]; then
                    print_dry_run "Caract√®res null d√©tect√©s dans: $file"
                    count=$((count + 1))
                else
                    # Nettoyage direct sans sauvegarde
                    if tr -d '\000' < "$file" > "$file.tmp" 2>/dev/null && mv "$file.tmp" "$file" 2>/dev/null; then
                        count=$((count + 1))
                        print_clean "Fichier nettoy√© : $file"
                    fi
                fi
            fi
        fi
    done < <(find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./.mypy_cache/*" -print0 2>/dev/null)
    
    if [ "$count" -gt 0 ]; then
        if [ "$DRY_RUN_MODE" = "true" ]; then
            echo -e "${WHITE}   üìä [DRY-RUN] $count fichiers Python avec caract√®res null d√©tect√©s${NC}"
        else
            print_success "$count fichiers Python nettoy√©s des caract√®res null"
            count_cleaned $count
        fi
    else
        print_success "Aucun caract√®re null d√©tect√© dans les fichiers Python"
    fi
}

# =============================================================================
# SECTION 5: EX√âCUTION PRINCIPALE
# =============================================================================

# Affichage de l'en-t√™te
print_header

# V√©rification du mode dry-run
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}üîç MODE DRY-RUN ACTIV√â - Aucun fichier ne sera supprim√©${NC}"
    echo -e "${YELLOW}======================================================${NC}"
    echo
fi

# Gestion des processus
manage_processes

# Nettoyage des caches Python
print_section "Nettoyage des caches Python"
safe_delete_dir "*/__pycache__" "Cache Python" "$DRY_RUN_MODE"
safe_delete "*.pyc" "Fichiers Python compil√©s" "$DRY_RUN_MODE"

# Nettoyage des fichiers temporaires
print_section "Nettoyage des fichiers temporaires"
safe_delete "*.tmp" "Fichiers temporaires .tmp" "$DRY_RUN_MODE"
safe_delete "*.temp" "Fichiers temporaires .temp" "$DRY_RUN_MODE"
safe_delete "*~" "Fichiers de sauvegarde ~" "$DRY_RUN_MODE"
safe_delete ".#*" "Fichiers de verrouillage" "$DRY_RUN_MODE"

# Nettoyage des fichiers macOS
print_section "Nettoyage des fichiers macOS"
# Nettoyage sp√©cial des fichiers ._* (AppleDouble) - m√™me dans les dossiers prot√©g√©s
echo -e "${BLUE}üîç Nettoyage des fichiers AppleDouble (.DS_Store, ._*)...${NC}"
if [ "$DRY_RUN_MODE" = true ]; then
    print_dry_run "Recherche de fichiers AppleDouble"
    count=$(find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
    echo -e "${WHITE}   üìä [DRY-RUN] $count fichiers AppleDouble trouv√©s${NC}"
else
    count=0
    while IFS= read -r -d '' file; do
        if rm -f "$file" 2>/dev/null; then
            count=$((count + 1))
            print_clean "Supprim√©: $file"
        fi
    done < <(find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    count_cleaned $count
fi

# Nettoyage des fichiers temporaires avec num√©ros de processus
echo -e "${BLUE}üîç Nettoyage des fichiers temporaires avec num√©ros de processus...${NC}"
if [ "$DRY_RUN_MODE" = true ]; then
    print_dry_run "Recherche de fichiers .!*"
    count=$(find . -name ".!*" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
    echo -e "${WHITE}   üìä [DRY-RUN] $count fichiers .!* trouv√©s${NC}"
else
    count=0
    while IFS= read -r -d '' file; do
        if rm -f "$file" 2>/dev/null; then
            count=$((count + 1))
            print_clean "Supprim√©: $file"
        fi
    done < <(find . -name ".!*" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    count_cleaned $count
fi

safe_delete ".!*" "Fichiers temporaires macOS" "$DRY_RUN_MODE"
safe_delete "*.clean" "Fichiers de nettoyage" "$DRY_RUN_MODE"
safe_delete ".DS_Store" "Fichiers .DS_Store" "$DRY_RUN_MODE"

# Nettoyage des logs
print_section "Nettoyage des logs"
safe_delete "*.log" "Fichiers de log (sauf athalia.log)" "$DRY_RUN_MODE"

# Nettoyage des caches de tests
print_section "Nettoyage des caches de tests"
safe_delete_dir ".pytest_cache" "Cache pytest" "$DRY_RUN_MODE"
safe_delete_dir ".benchmarks" "Cache benchmarks" "$DRY_RUN_MODE"
safe_delete_dir ".mypy_cache" "Cache mypy" "$DRY_RUN_MODE"

# Nettoyage des fichiers temporaires de tests
echo -e "${BLUE}üß™ Nettoyage des fichiers temporaires de tests...${NC}"
safe_delete "test_*_temp*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"
safe_delete "*_test_temp*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"
safe_delete "temp_test_*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"

# Nettoyage des caches de build
print_section "Nettoyage des caches de build"
safe_delete_dir "build" "Dossier build" "$DRY_RUN_MODE"
safe_delete_dir "dist" "Dossier dist" "$DRY_RUN_MODE"
safe_delete_dir "*.egg-info" "Dossiers egg-info" "$DRY_RUN_MODE"

# Nettoyage des fichiers de couverture
print_section "Nettoyage des fichiers de couverture"
safe_delete "*.coverage" "Fichiers de couverture" "$DRY_RUN_MODE"
safe_delete "coverage.xml" "Rapports de couverture XML" "$DRY_RUN_MODE"
safe_delete_dir "htmlcov" "Rapports HTML de couverture" "$DRY_RUN_MODE"

# Nettoyage des fichiers de profilage
print_section "Nettoyage des fichiers de profilage"
safe_delete "profile.out" "Fichiers de profilage" "$DRY_RUN_MODE"
safe_delete "*.prof" "Fichiers de profilage Python" "$DRY_RUN_MODE"

# Nettoyage des fichiers de recherche
print_section "Nettoyage des fichiers de recherche"
safe_delete_dir ".vscode" "Configuration VSCode" "$DRY_RUN_MODE"
safe_delete_dir ".idea" "Configuration IntelliJ" "$DRY_RUN_MODE"

# Nettoyage des dossiers temporaires
print_section "Nettoyage des dossiers temporaires"
safe_delete_dir "temp" "Dossiers temp" "$DRY_RUN_MODE"
safe_delete_dir "tmp" "Dossiers tmp" "$DRY_RUN_MODE"
safe_delete_dir "cache" "Dossiers cache" "$DRY_RUN_MODE"

# Nettoyage des fichiers corrompus
print_section "Nettoyage des fichiers corrompus"
safe_delete "*.f(f)" "Fichiers corrompus .f(f)" "$DRY_RUN_MODE"
safe_delete "*.corrupt" "Fichiers corrompus" "$DRY_RUN_MODE"
safe_delete "*.broken" "Fichiers cass√©s" "$DRY_RUN_MODE"

# Nettoyage des caract√®res null (s√©curis√©)
clean_null_bytes_safe

# Affichage du r√©sum√© et du pied de page
print_summary
print_footer 
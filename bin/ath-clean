#!/bin/bash
# üåü Nettoyage Complet du Projet Athalia - VERSION OPTIMIS√âE
# Version 5.1 - Nettoyage complet + Arr√™t des processus Athalia

set -euo pipefail

# =============================================================================
# SECTION 1: CONFIGURATION RAPIDE
# =============================================================================

# Couleurs simplifi√©es
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Variables optimis√©es
CLEANED_COUNT=0
DRY_RUN_MODE=false
KILL_PROCESSES=false

# D√©tection des options
for arg in "$@"; do
    case $arg in
        --dry-run|-d)
            DRY_RUN_MODE=true
            ;;
        --kill-processes|-k)
            KILL_PROCESSES=true
            ;;
        --help|-h)
            echo "Usage: ath-clean [OPTIONS]"
            echo "Options:"
            echo "  --dry-run, -d     Mode simulation (ne supprime rien)"
            echo "  --kill-processes, -k  Arr√™te tous les processus Athalia"
            echo "  --help, -h        Affiche cette aide"
            exit 0
            ;;
    esac
done

# =============================================================================
# SECTION 2: FONCTIONS D'AFFICHAGE OPTIMIS√âES
# =============================================================================

print_header() {
    echo -e "${BLUE}üöÄ Nettoyage Complet Athalia${NC}"
    echo
}

print_section() {
    echo -e "${BLUE}üìã $1${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_summary() {
    echo
    echo -e "${GREEN}üéØ Total nettoy√© : $CLEANED_COUNT √©l√©ments${NC}"
    echo
}

# =============================================================================
# SECTION 3: FONCTIONS DE GESTION DES PROCESSUS
# =============================================================================

# Fonction pour arr√™ter tous les processus Athalia
kill_athalia_processes() {
    print_section "Arr√™t des processus Athalia"
    
    # Patterns pour identifier les processus Athalia
    local patterns=(
        "athalia_core"
        "athalia_unified"
        "ath-"
        "pytest.*athalia"
        "python.*athalia"
        "python3.*athalia"
    )
    
    local killed_count=0
    
    for pattern in "${patterns[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            # Mode simulation - afficher les processus qui seraient arr√™t√©s
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${YELLOW}   [DRY-RUN] Processus qui seraient arr√™t√©s avec pattern '$pattern':${NC}"
                echo "$processes" | while read line; do
                    echo -e "${YELLOW}   [DRY-RUN] $line${NC}"
                done
                local count=$(echo "$processes" | wc -l)
                killed_count=$((killed_count + count))
            fi
        else
            # Mode r√©el - arr√™ter les processus
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${BLUE}   Arr√™t des processus avec pattern '$pattern'...${NC}"
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -TERM "$pid" 2>/dev/null; then
                            print_success "Arr√™t√© PID $pid: $cmd"
                            killed_count=$((killed_count + 1))
                        else
                            print_warning "Impossible d'arr√™ter PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        fi
    done
    
    # Attendre un peu pour les processus qui se terminent proprement
    if [ "$DRY_RUN_MODE" = false ] && [ $killed_count -gt 0 ]; then
        print_info "Attente de 3 secondes pour la terminaison propre..."
        sleep 3
        
        # Forcer l'arr√™t des processus qui n'ont pas r√©pondu au SIGTERM
        for pattern in "${patterns[@]}"; do
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -KILL "$pid" 2>/dev/null; then
                            print_warning "Forc√© l'arr√™t PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        done
    fi
    
    if [ $killed_count -gt 0 ]; then
        print_success "Total: $killed_count processus Athalia arr√™t√©s"
    else
        print_info "Aucun processus Athalia trouv√©"
    fi
    
    echo
}

# =============================================================================
# SECTION 4: FONCTIONS DE NETTOYAGE COMPLETES
# =============================================================================

# Fonction de nettoyage rapide avec patterns multiples
fast_clean() {
    local patterns=("$@")
    local description="${patterns[0]}"
    shift
    local pattern_list=("$@")
    
    echo -e "${BLUE}üîç $description...${NC}"
    
    local total_count=0
    
    for pattern in "${pattern_list[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" 2>/dev/null | wc -l)
            if [ $count -gt 0 ]; then
                echo -e "${YELLOW}   [DRY-RUN] $count fichiers trouv√©s avec pattern: $pattern${NC}"
                total_count=$((total_count + count))
            fi
        else
            local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -delete 2>/dev/null | wc -l)
            if [ $count -gt 0 ]; then
                print_success "$count √©l√©ments nettoy√©s avec pattern: $pattern"
                total_count=$((total_count + count))
            fi
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
}

# Fonction de nettoyage des dossiers cache
clean_cache_directories() {
    local dirs=("$@")
    local description="$1"
    
    echo -e "${BLUE}üóÇÔ∏è  $description...${NC}"
    
    local total_count=0
    
    for dir in "${dirs[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                echo -e "${YELLOW}   [DRY-RUN] Dossier trouv√©: $dir ($size)${NC}"
                total_count=$((total_count + 1))
            fi
        else
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                rm -rf "$dir" 2>/dev/null
                print_success "Dossier supprim√©: $dir ($size)"
                total_count=$((total_count + 1))
            fi
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
}

# =============================================================================
# SECTION 5: EX√âCUTION PRINCIPALE COMPL√àTE
# =============================================================================

# Affichage de l'en-t√™te
print_header

# Arr√™t des processus Athalia si demand√©
if [ "$KILL_PROCESSES" = true ]; then
    kill_athalia_processes
fi

# Nettoyage complet des fichiers AppleDouble et macOS
print_section "Nettoyage des fichiers AppleDouble et macOS"
fast_clean "Fichiers syst√®me macOS" "._*" ".DS_Store" ".!*" "*.noindex" "Thumbs.db" "desktop.ini"

# Nettoyage complet des fichiers Python compil√©s
print_section "Nettoyage des fichiers Python compil√©s"
fast_clean "Fichiers Python compil√©s" "*.pyc" "*.pyo" "*.pyd" "__pycache__" "*.so" "*.dll" "*.dylib"

# Nettoyage complet des caches de tests et outils
print_section "Nettoyage des caches de tests et outils"
fast_clean "Caches de tests" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "coverage.xml" "htmlcov" ".tox" ".cache"

# Nettoyage complet des fichiers de couverture
print_section "Nettoyage des fichiers de couverture"
fast_clean "Fichiers de couverture" "*.coverage" "coverage.xml" "htmlcov" ".coverage.*" "coverage_html" "cov.xml"

# Nettoyage complet des fichiers temporaires
print_section "Nettoyage des fichiers temporaires"
fast_clean "Fichiers temporaires" "*.tmp" "*.temp" "*.swp" "*.swo" "*~" "*.bak" "*.backup" "*.orig"

# Nettoyage complet des fichiers de build
print_section "Nettoyage des fichiers de build"
fast_clean "Fichiers de build" "build" "dist" "*.egg-info" "*.egg" "__pycache__" "*.pyc" "*.pyo"

# Nettoyage complet des fichiers de logs
print_section "Nettoyage des fichiers de logs"
fast_clean "Fichiers de logs" "*.log" "logs" "*.out" "*.err" "debug.log" "error.log"

# Nettoyage complet des fichiers de donn√©es temporaires
print_section "Nettoyage des fichiers de donn√©es temporaires"
fast_clean "Fichiers de donn√©es temporaires" "*.db" "*.sqlite" "*.sqlite3" "*.cache" "*.dat" "*.tmp"

# Nettoyage complet des fichiers corrompus
print_section "Nettoyage des fichiers corrompus"
fast_clean "Fichiers corrompus" "*.f(f)" "*.corrupt" "*.broken"

# Nettoyage des dossiers cache sp√©cifiques
print_section "Nettoyage des dossiers cache sp√©cifiques"
clean_cache_directories "Dossiers cache" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "htmlcov" ".tox" ".cache" "build" "dist" "*.egg-info" "__pycache__"

# Nettoyage des caract√®res null des fichiers Python
print_section "Nettoyage des caract√®res null"
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}   [DRY-RUN] Recherche de fichiers avec caract√®res null${NC}"
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        echo -e "${YELLOW}   [DRY-RUN] Fichier avec caract√®res null: $file${NC}"
    done
else
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        if [ -f "$file" ]; then
            tr -d '\000' < "$file" > "$file.tmp" 2>/dev/null && mv "$file.tmp" "$file" 2>/dev/null
            print_success "Nettoy√©: $file"
            CLEANED_COUNT=$((CLEANED_COUNT + 1))
        fi
    done
fi

# Nettoyage des fichiers de configuration temporaires
print_section "Nettoyage des fichiers de configuration temporaires"
fast_clean "Fichiers de configuration temporaires" "*.cfg.tmp" "*.ini.tmp" "*.yaml.tmp" "*.yml.tmp" "*.json.tmp"

# Nettoyage des fichiers de documentation temporaires
print_section "Nettoyage des fichiers de documentation temporaires"
fast_clean "Fichiers de documentation temporaires" "*.md.tmp" "*.rst.tmp" "*.txt.tmp" "docs/_build" "docs/build"

# Nettoyage des fichiers de IDE/√©diteurs
print_section "Nettoyage des fichiers d'√©diteurs"
fast_clean "Fichiers d'√©diteurs" ".vscode/settings.json.tmp" ".idea/workspace.xml.tmp" "*.sublime-*" ".editorconfig.tmp"

# Affichage du r√©sum√©
print_summary 
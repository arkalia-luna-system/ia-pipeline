#!/bin/bash
# ğŸŒŸ Nettoyage Complet du Projet Athalia/Arkalia - VERSION ULTRA-SÃ‰CURISÃ‰E
# Version 2.0 - Protection maximale contre la suppression accidentelle
# Inclut des vÃ©rifications de sÃ©curitÃ© et des exclusions strictes

set -euo pipefail  # Mode strict - arrÃªt sur erreur

echo "ğŸ”’ Nettoyage Athalia/Arkalia - MODE SÃ‰CURISÃ‰"
echo "=============================================="

# Variables de sÃ©curitÃ©
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
CLEANED_FILES=0
CLEANED_DIRS=0
CLEANED_PROCESSES=0
DRY_RUN_MODE=${1:-false}

# LISTE DES FICHIERS/DOSSIERS CRITIQUES - JAMAIS SUPPRIMÃ‰S
CRITICAL_PATHS=(
    ".git"
    ".venv"
    "venv"
    "env"
    "node_modules"
    "data"
    "config"
    "docs"
    "tests"
    "athalia_core"
    "bin"
    "scripts"
    "setup"
    "tools"
    "plugins"
    "templates"
    "prompts"
    "blueprints_history"
    "backups"
    "logs"
    "archive"
    "*.py"
    "*.md"
    "*.yaml"
    "*.yml"
    "*.json"
    "*.toml"
    "*.cfg"
    "*.ini"
    "*.sh"
    "*.txt"
    "*.rst"
    "*.html"
    "*.css"
    "*.js"
    "*.ts"
    "*.vue"
    "*.jsx"
    "*.tsx"
    "*.sql"
    "*.db"
    "*.sqlite"
    "*.sqlite3"
    "*.log"
    "*.lock"
    "requirements.txt"
    "setup.py"
    "pyproject.toml"
    "Cargo.toml"
    "package.json"
    "composer.json"
    "Gemfile"
    "Dockerfile"
    "docker-compose.yml"
    "Makefile"
    "README*"
    "CHANGELOG*"
    "LICENSE*"
    "ROADMAP*"
    "CONTRIBUTING*"
    "CODE_OF_CONDUCT*"
    ".gitignore"
    ".gitattributes"
    ".editorconfig"
    ".eslintrc*"
    ".prettierrc*"
    ".babelrc*"
    ".env*"
    ".dockerignore"
    ".npmrc"
    ".yarnrc"
    ".bowerrc"
    ".jshintrc"
    ".jscsrc"
    ".stylelintrc*"
    ".browserslistrc"
    ".babelrc*"
    ".postcssrc*"
    ".eslintignore"
    ".prettierignore"
    ".stylelintignore"
    ".flowconfig"
    ".flowconfig.js"
    ".flowconfig.json"
    ".babelrc.js"
    ".babelrc.json"
    ".postcssrc.js"
    ".postcssrc.json"
    ".eslintrc.js"
    ".eslintrc.json"
    ".prettierrc.js"
    ".prettierrc.json"
    ".stylelintrc.js"
    ".stylelintrc.json"
    ".jshintrc.js"
    ".jshintrc.json"
    ".jscsrc.js"
    ".jscsrc.json"
    ".browserslistrc.js"
    ".browserslistrc.json"
    ".babelrc.js"
    ".babelrc.json"
    ".postcssrc.js"
    ".postcssrc.json"
    ".eslintrc.js"
    ".eslintrc.json"
    ".prettierrc.js"
    ".prettierrc.json"
    ".stylelintrc.js"
    ".stylelintrc.json"
    ".jshintrc.js"
    ".jshintrc.json"
    ".jscsrc.js"
    ".jscsrc.json"
    ".browserslistrc.js"
    ".browserslistrc.json"
)

# Fonction de vÃ©rification de sÃ©curitÃ©
is_critical_path() {
    local path="$1"
    
    # Exception spÃ©ciale : les fichiers ._* (AppleDouble) ne sont jamais critiques
    # Sauf s'ils sont dans des dossiers vraiment critiques
    if [[ "$path" == *"/._"* ]] || [[ "$path" == "._"* ]]; then
        # Permettre la suppression des ._* mÃªme dans les caches
        if [[ "$path" == *"/.mypy_cache/"* ]] || [[ "$path" == *"/__pycache__/"* ]] || [[ "$path" == *"/.pytest_cache/"* ]]; then
            return 1  # Non critique - peut Ãªtre supprimÃ©
        fi
        # Pour les autres dossiers, vÃ©rifier s'ils sont vraiment critiques
        for critical in "${CRITICAL_PATHS[@]}"; do
            if [[ "$path" == *"$critical"* ]] || [[ "$path" == "$critical" ]]; then
                # Exception : permettre ._* dans les caches mÃªme s'ils sont dans des dossiers critiques
                if [[ "$critical" == ".mypy_cache" ]] || [[ "$critical" == "__pycache__" ]] || [[ "$critical" == ".pytest_cache" ]]; then
                    return 1  # Non critique - peut Ãªtre supprimÃ©
                fi
                return 0  # Critique - ne pas supprimer
            fi
        done
        return 1  # Non critique - peut Ãªtre supprimÃ©
    fi
    
    for critical in "${CRITICAL_PATHS[@]}"; do
        if [[ "$path" == *"$critical"* ]] || [[ "$path" == "$critical" ]]; then
            return 0  # Critique - ne pas supprimer
        fi
    done
    return 1  # Non critique - peut Ãªtre supprimÃ©
}

# Fonction de vÃ©rification de sÃ©curitÃ© renforcÃ©e
is_safe_to_delete() {
    local path="$1"
    
    # VÃ©rifications de sÃ©curitÃ©
    if [[ "$path" == "/" ]] || [[ "$path" == "/home" ]] || [[ "$path" == "/Users" ]]; then
        echo "ğŸš¨ ATTENTION: Tentative de suppression d'un rÃ©pertoire systÃ¨me critique: $path"
        return 1
    fi
    
    if [[ "$path" == *".."* ]]; then
        echo "ğŸš¨ ATTENTION: Chemin suspect dÃ©tectÃ©: $path"
        return 1
    fi
    
    if [[ "$path" == *"/"* ]] && [[ ! "$path" =~ ^\./ ]]; then
        echo "ğŸš¨ ATTENTION: Chemin absolu dÃ©tectÃ©: $path"
        return 1
    fi
    
    if is_critical_path "$path"; then
        echo "ğŸ›¡ï¸  PROTECTION: Fichier critique prÃ©servÃ©: $path"
        return 1
    fi
    
    return 0
}

# Fonction pour compter les fichiers supprimÃ©s
count_cleaned() {
    local count=$1
    if [ $count -gt 0 ]; then
        echo "   âœ… $count Ã©lÃ©ments nettoyÃ©s"
        CLEANED_FILES=$((CLEANED_FILES + count))
    fi
}

# Fonction de nettoyage sÃ©curisÃ©
safe_delete() {
    local pattern="$1"
    local description="$2"
    local dry_run=${3:-false}
    
    echo "ğŸ” $description..."
    
    if [ "$dry_run" = true ]; then
        echo "   ğŸ” [DRY-RUN] Recherche de fichiers: $pattern"
        local count=$(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
        echo "   ğŸ“Š [DRY-RUN] $count fichiers trouvÃ©s"
        return
    fi
    
    local count=0
    while IFS= read -r -d '' file; do
        if is_safe_to_delete "$file"; then
            if rm -f "$file" 2>/dev/null; then
                count=$((count + 1))
                echo "   ğŸ—‘ï¸  SupprimÃ©: $file"
            fi
        fi
    done < <(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    
    count_cleaned $count
}

# Fonction de nettoyage de dossiers sÃ©curisÃ©
safe_delete_dir() {
    local pattern="$1"
    local description="$2"
    local dry_run=${3:-false}
    
    echo "ğŸ” $description..."
    
    if [ "$dry_run" = true ]; then
        echo "   ğŸ” [DRY-RUN] Recherche de dossiers: $pattern"
        local count=$(find . -path "$pattern" -type d -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
        echo "   ğŸ“Š [DRY-RUN] $count dossiers trouvÃ©s"
        return
    fi
    
    local count=0
    while IFS= read -r -d '' dir; do
        if is_safe_to_delete "$dir"; then
            if rm -rf "$dir" 2>/dev/null; then
                count=$((count + 1))
                echo "   ğŸ—‘ï¸  SupprimÃ©: $dir"
            fi
        fi
    done < <(find . -path "$pattern" -type d -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    
    count_cleaned $count
}

# Fonction pour gÃ©rer les processus
manage_processes() {
    echo "ğŸ” Analyse des processus Athalia..."
    
    # VÃ©rifier les processus Python athalia_core
    ATHALIA_PROCESSES=$(ps aux | grep -c "[a]thalia_core.main" 2>/dev/null || echo "0")
    if [ "$ATHALIA_PROCESSES" -gt 0 ] 2>/dev/null; then
        echo "   âš ï¸  $ATHALIA_PROCESSES processus Athalia dÃ©tectÃ©s"
        echo "   ğŸ’¡ Utilisez 'ark-process-check.sh' pour les gÃ©rer"
        
        if [ "$DRY_RUN_MODE" != true ]; then
            read -p "   Voulez-vous arrÃªter les processus Athalia ? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "   ğŸ”ª ArrÃªt des processus Athalia..."
                pkill -f "athalia_core.main" 2>/dev/null
                CLEANED_PROCESSES=$ATHALIA_PROCESSES
                echo "   âœ… $ATHALIA_PROCESSES processus arrÃªtÃ©s"
            fi
        fi
    else
        echo "   âœ… Aucun processus Athalia en cours"
    fi
}

# Fonction pour nettoyer les caractÃ¨res null de maniÃ¨re sÃ©curisÃ©e
clean_null_bytes_safe() {
    echo "ğŸ”§ Nettoyage des caractÃ¨res null (corruption de fichiers)..."
    
    local count=0
    while IFS= read -r -d '' file; do
        if is_safe_to_delete "$file"; then
            if grep -q $'\x00' "$file" 2>/dev/null; then
                # Sauvegarder le fichier original
                cp "$file" "$file.backup" 2>/dev/null
                # Supprimer les caractÃ¨res null
                if tr -d '\000' < "$file" > "$file.tmp" 2>/dev/null && mv "$file.tmp" "$file" 2>/dev/null; then
                    count=$((count + 1))
                    echo "   ğŸ”§ Fichier nettoyÃ© : $file"
                fi
            fi
        fi
    done < <(find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    
    if [ "$count" -gt 0 ]; then
        echo "   âœ… $count fichiers Python nettoyÃ©s des caractÃ¨res null"
        count_cleaned $count
    else
        echo "   âœ… Aucun caractÃ¨re null dÃ©tectÃ©"
    fi
}

# VÃ©rification du mode dry-run
if [ "$DRY_RUN_MODE" = true ]; then
    echo "ğŸ” MODE DRY-RUN ACTIVÃ‰ - Aucun fichier ne sera supprimÃ©"
    echo "======================================================"
fi

# Gestion des processus
manage_processes

echo "ğŸ“ Nettoyage des caches Python..."
safe_delete_dir "*/__pycache__" "Cache Python" "$DRY_RUN_MODE"
safe_delete "*.pyc" "Fichiers Python compilÃ©s" "$DRY_RUN_MODE"

echo "ğŸ—‘ï¸ Nettoyage des fichiers temporaires..."
safe_delete "*.tmp" "Fichiers temporaires .tmp" "$DRY_RUN_MODE"
safe_delete "*.temp" "Fichiers temporaires .temp" "$DRY_RUN_MODE"
safe_delete "*~" "Fichiers de sauvegarde ~" "$DRY_RUN_MODE"
safe_delete ".#*" "Fichiers de verrouillage" "$DRY_RUN_MODE"

echo "ğŸ Nettoyage des fichiers macOS..."
# Nettoyage spÃ©cial des fichiers ._* (AppleDouble) - mÃªme dans les dossiers protÃ©gÃ©s
echo "ğŸ” Nettoyage des fichiers AppleDouble (.DS_Store, ._*)..."
if [ "$DRY_RUN_MODE" = true ]; then
    echo "   ğŸ” [DRY-RUN] Recherche de fichiers AppleDouble"
    count=$(find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
    echo "   ğŸ“Š [DRY-RUN] $count fichiers AppleDouble trouvÃ©s"
else
    count=0
    while IFS= read -r -d '' file; do
        if rm -f "$file" 2>/dev/null; then
            count=$((count + 1))
            echo "   ğŸ—‘ï¸  SupprimÃ©: $file"
        fi
    done < <(find . -name "._*" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    count_cleaned $count
fi

# Nettoyage des fichiers temporaires avec numÃ©ros de processus
echo "ğŸ” Nettoyage des fichiers temporaires avec numÃ©ros de processus..."
if [ "$DRY_RUN_MODE" = true ]; then
    echo "   ğŸ” [DRY-RUN] Recherche de fichiers .!*"
    count=$(find . -name ".!*" -not -path "./.git/*" -not -path "./.venv/*" 2>/dev/null | wc -l)
    echo "   ğŸ“Š [DRY-RUN] $count fichiers .!* trouvÃ©s"
else
    count=0
    while IFS= read -r -d '' file; do
        if rm -f "$file" 2>/dev/null; then
            count=$((count + 1))
            echo "   ğŸ—‘ï¸  SupprimÃ©: $file"
        fi
    done < <(find . -name ".!*" -not -path "./.git/*" -not -path "./.venv/*" -print0 2>/dev/null)
    count_cleaned $count
fi

safe_delete ".!*" "Fichiers temporaires macOS" "$DRY_RUN_MODE"
safe_delete "*.clean" "Fichiers de nettoyage" "$DRY_RUN_MODE"
safe_delete ".DS_Store" "Fichiers .DS_Store" "$DRY_RUN_MODE"

echo "ğŸ“ Nettoyage des logs..."
safe_delete "*.log" "Fichiers de log (sauf athalia.log)" "$DRY_RUN_MODE"

echo "ğŸ§ª Nettoyage des caches de tests..."
safe_delete_dir ".pytest_cache" "Cache pytest" "$DRY_RUN_MODE"
safe_delete_dir ".benchmarks" "Cache benchmarks" "$DRY_RUN_MODE"
safe_delete_dir ".mypy_cache" "Cache mypy" "$DRY_RUN_MODE"

# Nettoyage des fichiers temporaires de tests
echo "ğŸ§ª Nettoyage des fichiers temporaires de tests..."
safe_delete "test_*_temp*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"
safe_delete "*_test_temp*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"
safe_delete "temp_test_*" "Fichiers temporaires de tests" "$DRY_RUN_MODE"

echo "ğŸ“¦ Nettoyage des caches de build..."
safe_delete_dir "build" "Dossier build" "$DRY_RUN_MODE"
safe_delete_dir "dist" "Dossier dist" "$DRY_RUN_MODE"
safe_delete_dir "*.egg-info" "Dossiers egg-info" "$DRY_RUN_MODE"

echo "ğŸ¨ Nettoyage des fichiers de couverture..."
safe_delete "*.coverage" "Fichiers de couverture" "$DRY_RUN_MODE"
safe_delete "coverage.xml" "Rapports de couverture XML" "$DRY_RUN_MODE"
safe_delete_dir "htmlcov" "Rapports HTML de couverture" "$DRY_RUN_MODE"

echo "ğŸ“‹ Nettoyage des fichiers de profilage..."
safe_delete "profile.out" "Fichiers de profilage" "$DRY_RUN_MODE"
safe_delete "*.prof" "Fichiers de profilage Python" "$DRY_RUN_MODE"

echo "ğŸ” Nettoyage des fichiers de recherche..."
safe_delete_dir ".vscode" "Configuration VSCode" "$DRY_RUN_MODE"
safe_delete_dir ".idea" "Configuration IntelliJ" "$DRY_RUN_MODE"

echo "ğŸ“ Nettoyage des dossiers temporaires..."
safe_delete_dir "temp" "Dossiers temp" "$DRY_RUN_MODE"
safe_delete_dir "tmp" "Dossiers tmp" "$DRY_RUN_MODE"
safe_delete_dir "cache" "Dossiers cache" "$DRY_RUN_MODE"

echo "ğŸ§¹ Nettoyage des fichiers corrompus..."
safe_delete "*.f(f)" "Fichiers corrompus .f(f)" "$DRY_RUN_MODE"
safe_delete "*.corrupt" "Fichiers corrompus" "$DRY_RUN_MODE"
safe_delete "*.broken" "Fichiers cassÃ©s" "$DRY_RUN_MODE"

# Nettoyage des caractÃ¨res null (sÃ©curisÃ©)
clean_null_bytes_safe

echo ""
echo "ğŸ¯ RÃ©sumÃ© du nettoyage :"
echo "   ğŸ“Š Total d'Ã©lÃ©ments nettoyÃ©s : $CLEANED_FILES"
echo "   ğŸ“ Dossiers nettoyÃ©s : $CLEANED_DIRS"
echo "   ğŸ”„ Processus arrÃªtÃ©s : $CLEANED_PROCESSES"
echo ""
echo "ğŸ›¡ï¸  SÃ©curitÃ© :"
echo "   âœ… Tous les fichiers critiques ont Ã©tÃ© prÃ©servÃ©s"
echo "   âœ… Aucun fichier systÃ¨me n'a Ã©tÃ© touchÃ©"
echo "   âœ… VÃ©rifications de sÃ©curitÃ© activÃ©es"
echo ""
if [ "$DRY_RUN_MODE" = true ]; then
    echo "ğŸ” MODE DRY-RUN - Aucun fichier n'a Ã©tÃ© supprimÃ©"
else
    echo "âœ… Nettoyage terminÃ© ! Le projet Athalia/Arkalia est maintenant propre et optimisÃ©."
fi
echo ""
echo "ğŸ’¡ Conseils :"
echo "   - ExÃ©cutez 'ath-clean --dry-run' pour tester sans supprimer"
echo "   - Utilisez 'ark-process-check.sh' pour surveiller les processus"
echo "   - Les fichiers critiques sont automatiquement prÃ©servÃ©s"
echo "   - La configuration a Ã©tÃ© optimisÃ©e pour les performances"
echo ""
echo "ğŸš€ Pour redÃ©marrer proprement :"
echo "   python3 -m athalia_core.main" 
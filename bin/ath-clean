#!/bin/bash
# üåü Nettoyage S√âCURIS√â du Projet Athalia - VERSION PROT√âG√âE
# Version 6.0 - Nettoyage s√©curis√© + Protection des fichiers importants

set -euo pipefail

# =============================================================================
# SECTION 1: CONFIGURATION S√âCURIS√âE
# =============================================================================

# Couleurs simplifi√©es
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Variables optimis√©es
CLEANED_COUNT=0
DRY_RUN_MODE=false
KILL_PROCESSES=false
FORCE_APPLEDOUBLE=false

# D√©tection des options
for arg in "$@"; do
    case $arg in
        --dry-run|-d)
            DRY_RUN_MODE=true
            ;;
        --kill-processes|-k)
            KILL_PROCESSES=true
            ;;
        --force-appledouble|-f)
            FORCE_APPLEDOUBLE=true
            ;;
        --help|-h)
            echo "Usage: ath-clean [OPTIONS]"
            echo "Options:"
            echo "  --dry-run, -d     Mode simulation (ne supprime rien)"
            echo "  --kill-processes, -k  Arr√™te tous les processus Athalia"
            echo "  --force-appledouble, -f  Force la suppression des fichiers AppleDouble"
            echo "  --help, -h        Affiche cette aide"
            echo ""
            echo "‚ö†Ô∏è  ATTENTION: Ce script est maintenant S√âCURIS√â et ne supprime que les fichiers temporaires"
            echo "üõ°Ô∏è  Les fichiers importants (tests, code, docs) sont PROT√âG√âS"
            exit 0
            ;;
    esac
done

# =============================================================================
# SECTION 2: FONCTIONS D'AFFICHAGE OPTIMIS√âES
# =============================================================================

print_header() {
    echo -e "${BLUE}üöÄ Nettoyage S√âCURIS√â Athalia${NC}"
    echo -e "${YELLOW}üõ°Ô∏è  Mode PROTECTION ACTIV√âE - Fichiers importants pr√©serv√©s${NC}"
    echo
}

print_section() {
    echo -e "${BLUE}üìã $1${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_summary() {
    echo
    echo -e "${GREEN}üéØ Total nettoy√© : $CLEANED_COUNT √©l√©ments${NC}"
    echo -e "${BLUE}üõ°Ô∏è  Fichiers importants pr√©serv√©s avec succ√®s${NC}"
    echo
}

# =============================================================================
# SECTION 3: FONCTIONS DE PROTECTION
# =============================================================================

# Fonction pour v√©rifier si un fichier est important (√† prot√©ger)
is_important_file() {
    local file="$1"
    
    # Liste des patterns de fichiers importants √† PROT√âGER
    local important_patterns=(
        "tests/"
        "athalia_core/"
        "docs/"
        "config/"
        "bin/"
        "scripts/"
        "*.py"
        "*.md"
        "*.yaml"
        "*.yml"
        "*.json"
        "*.txt"
        "*.sh"
        "*.js"
        "*.html"
        "*.css"
        "*.xml"
        "*.toml"
        "*.cfg"
        "*.ini"
        "requirements"
        "setup.py"
        "pyproject.toml"
        "Cargo.toml"
        "package.json"
        "Makefile"
        "Dockerfile"
        "docker-compose"
        "README"
        "LICENSE"
        ".gitignore"
        ".env"
        "*.sql"
        "*.sqlite"
        "*.db"
    )
    
    # V√©rifier si le fichier correspond √† un pattern important
    for pattern in "${important_patterns[@]}"; do
        if [[ "$file" == *"$pattern"* ]] || [[ "$file" == "$pattern" ]]; then
            return 0  # Fichier important
        fi
    done
    
    return 1  # Fichier non important
}

# Fonction pour v√©rifier si un dossier est important
is_important_directory() {
    local dir="$1"
    
    # Liste des dossiers importants √† PROT√âGER
    local important_dirs=(
        "tests"
        "athalia_core"
        "docs"
        "config"
        "bin"
        "scripts"
        "plugins"
        "templates"
        "data"
        "backups"
        "blueprints_history"
        "dashboard"
        "prompts"
        "setup"
        "tools"
    )
    
    # V√©rifier si le dossier est important
    for important_dir in "${important_dirs[@]}"; do
        if [[ "$dir" == "$important_dir" ]] || [[ "$dir" == "./$important_dir" ]] || [[ "$dir" == "*/$important_dir" ]]; then
            return 0  # Dossier important
        fi
    done
    
    return 1  # Dossier non important
}

# =============================================================================
# SECTION 4: FONCTIONS DE GESTION DES PROCESSUS
# =============================================================================

# Fonction pour arr√™ter tous les processus Athalia
kill_athalia_processes() {
    print_section "Arr√™t des processus Athalia"
    
    # Patterns pour identifier les processus Athalia
    local patterns=(
        "athalia_core"
        "athalia_unified"
        "ath-"
        "pytest.*athalia"
        "python.*athalia"
        "python3.*athalia"
    )
    
    local killed_count=0
    
    for pattern in "${patterns[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            # Mode simulation - afficher les processus qui seraient arr√™t√©s
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${YELLOW}   [DRY-RUN] Processus qui seraient arr√™t√©s avec pattern '$pattern':${NC}"
                echo "$processes" | while read line; do
                    echo -e "${YELLOW}   [DRY-RUN] $line${NC}"
                done
                local count=$(echo "$processes" | wc -l)
                killed_count=$((killed_count + count))
            fi
        else
            # Mode r√©el - arr√™ter les processus
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo -e "${BLUE}   Arr√™t des processus avec pattern '$pattern'...${NC}"
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -TERM "$pid" 2>/dev/null; then
                            print_success "Arr√™t√© PID $pid: $cmd"
                            killed_count=$((killed_count + 1))
                        else
                            print_warning "Impossible d'arr√™ter PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        fi
    done
    
    # Attendre un peu pour les processus qui se terminent proprement
    if [ "$DRY_RUN_MODE" = false ] && [ $killed_count -gt 0 ]; then
        print_info "Attente de 3 secondes pour la terminaison propre..."
        sleep 3
        
        # Forcer l'arr√™t des processus qui n'ont pas r√©pondu au SIGTERM
        for pattern in "${patterns[@]}"; do
            local processes=$(ps aux | grep -E "$pattern" | grep -v grep | grep -v "ath-clean" || true)
            if [ -n "$processes" ]; then
                echo "$processes" | while read line; do
                    local pid=$(echo "$line" | awk '{print $2}')
                    local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
                    if [ -n "$pid" ] && [ "$pid" != "$$" ]; then
                        if kill -KILL "$pid" 2>/dev/null; then
                            print_warning "Forc√© l'arr√™t PID $pid: $cmd"
                        fi
                    fi
                done
            fi
        done
    fi
    
    if [ $killed_count -gt 0 ]; then
        print_success "Total: $killed_count processus Athalia arr√™t√©s"
    else
        print_info "Aucun processus Athalia trouv√©"
    fi
    
    echo
}

# =============================================================================
# SECTION 5: FONCTIONS DE NETTOYAGE S√âCURIS√âES
# =============================================================================

# Fonction de nettoyage s√©curis√© avec protection des fichiers importants
secure_clean() {
    local patterns=("$@")
    local description="${patterns[0]}"
    shift
    local pattern_list=("$@")
    
    echo -e "${BLUE}üîç $description (S√âCURIS√â)...${NC}"
    
    local total_count=0
    local protected_count=0
    
    for pattern in "${pattern_list[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            # Mode simulation - afficher ce qui serait nettoy√©
            while IFS= read -r -d '' file; do
                if is_important_file "$file" || is_important_directory "$file"; then
                    echo -e "${YELLOW}   [DRY-RUN] PROT√âG√â: $file${NC}"
                    protected_count=$((protected_count + 1))
                else
                    echo -e "${YELLOW}   [DRY-RUN] Nettoy√©: $file${NC}"
                    total_count=$((total_count + 1))
                fi
            done < <(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -print0 2>/dev/null)
        else
            # Mode r√©el - nettoyer avec protection
            while IFS= read -r -d '' file; do
                if is_important_file "$file" || is_important_directory "$file"; then
                    print_warning "PROT√âG√â: $file"
                    protected_count=$((protected_count + 1))
                else
                    if rm -rf "$file" 2>/dev/null; then
                        print_success "Nettoy√©: $file"
                        total_count=$((total_count + 1))
                    fi
                fi
            done < <(find . -path "$pattern" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -print0 2>/dev/null)
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
    
    if [ $protected_count -gt 0 ]; then
        print_info "$protected_count fichiers/dossiers importants prot√©g√©s"
    fi
}

# Fonction de nettoyage des dossiers cache s√©curis√©e
secure_clean_cache_directories() {
    local dirs=("$@")
    local description="$1"
    
    echo -e "${BLUE}üóÇÔ∏è  $description (S√âCURIS√â)...${NC}"
    
    local total_count=0
    local protected_count=0
    
    for dir in "${dirs[@]}"; do
        if [ "$DRY_RUN_MODE" = true ]; then
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                if is_important_directory "$dir"; then
                    echo -e "${YELLOW}   [DRY-RUN] PROT√âG√â: $dir ($size)${NC}"
                    protected_count=$((protected_count + 1))
                else
                    echo -e "${YELLOW}   [DRY-RUN] Dossier trouv√©: $dir ($size)${NC}"
                    total_count=$((total_count + 1))
                fi
            fi
        else
            if [ -d "$dir" ]; then
                local size=$(du -sh "$dir" 2>/dev/null | cut -f1)
                if is_important_directory "$dir"; then
                    print_warning "PROT√âG√â: $dir ($size)"
                    protected_count=$((protected_count + 1))
                else
                    if rm -rf "$dir" 2>/dev/null; then
                        print_success "Dossier supprim√©: $dir ($size)"
                        total_count=$((total_count + 1))
                    fi
                fi
            fi
        fi
    done
    
    if [ $total_count -gt 0 ]; then
        CLEANED_COUNT=$((CLEANED_COUNT + total_count))
    fi
    
    if [ $protected_count -gt 0 ]; then
        print_info "$protected_count dossiers importants prot√©g√©s"
    fi
}

# =============================================================================
# SECTION 6: FONCTIONS DE PR√âVENTION
# =============================================================================

# Fonction pour d√©sactiver la cr√©ation de fichiers AppleDouble
disable_appledouble_creation() {
    print_section "D√©sactivation de la cr√©ation de fichiers AppleDouble"
    
    if [ "$DRY_RUN_MODE" = true ]; then
        echo -e "${YELLOW}   [DRY-RUN] V√©rification de la configuration AppleDouble...${NC}"
        if defaults read com.apple.desktopservices DSDontWriteNetworkStores 2>/dev/null | grep -q "1"; then
            echo -e "${YELLOW}   [DRY-RUN] Configuration AppleDouble d√©j√† d√©sactiv√©e${NC}"
        else
            echo -e "${YELLOW}   [DRY-RUN] Configuration AppleDouble √† d√©sactiver${NC}"
        fi
    else
        # D√©sactiver la cr√©ation de fichiers AppleDouble sur les volumes r√©seau
        if defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true 2>/dev/null; then
            print_success "Cr√©ation de fichiers AppleDouble d√©sactiv√©e sur les volumes r√©seau"
        else
            print_warning "Impossible de d√©sactiver la cr√©ation de fichiers AppleDouble (droits insuffisants)"
        fi
        
        # D√©sactiver la cr√©ation de fichiers AppleDouble localement
        if defaults write com.apple.desktopservices DSDontWriteUSBStores -bool true 2>/dev/null; then
            print_success "Cr√©ation de fichiers AppleDouble d√©sactiv√©e sur les volumes USB"
        else
            print_warning "Impossible de d√©sactiver la cr√©ation de fichiers AppleDouble USB (droits insuffisants)"
        fi
        
        # Red√©marrer Finder pour appliquer les changements
        if killall Finder 2>/dev/null; then
            print_info "Finder red√©marr√© pour appliquer les changements"
        fi
    fi
    
    echo
}

# =============================================================================
# SECTION 7: EX√âCUTION PRINCIPALE S√âCURIS√âE
# =============================================================================

# Affichage de l'en-t√™te
print_header

# D√©sactivation de la cr√©ation de fichiers AppleDouble
disable_appledouble_creation

# Arr√™t des processus Athalia si demand√©
if [ "$KILL_PROCESSES" = true ]; then
    kill_athalia_processes
fi

# Nettoyage S√âCURIS√â des fichiers AppleDouble et macOS (seulement les fichiers syst√®me)
print_section "Nettoyage S√âCURIS√â des fichiers AppleDouble et macOS"
secure_clean "Fichiers syst√®me macOS" "._*" ".DS_Store" ".!*" "*.noindex" "Thumbs.db" "desktop.ini"

# Nettoyage S√âCURIS√â des fichiers Python compil√©s (seulement les caches)
print_section "Nettoyage S√âCURIS√â des fichiers Python compil√©s"
secure_clean "Fichiers Python compil√©s" "*.pyc" "*.pyo" "__pycache__"

# Nettoyage S√âCURIS√â des caches de tests et outils (seulement les caches)
print_section "Nettoyage S√âCURIS√â des caches de tests et outils"
secure_clean "Caches de tests" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "coverage.xml" "htmlcov" ".tox" ".cache"

# Nettoyage S√âCURIS√â des fichiers de couverture (seulement les rapports)
print_section "Nettoyage S√âCURIS√â des fichiers de couverture"
secure_clean "Fichiers de couverture" "*.coverage" "coverage.xml" "htmlcov" ".coverage.*" "coverage_html" "cov.xml"

# Nettoyage S√âCURIS√â des fichiers temporaires (seulement les fichiers vraiment temporaires)
print_section "Nettoyage S√âCURIS√â des fichiers temporaires"
secure_clean "Fichiers temporaires" "*.tmp" "*.temp" "*.swp" "*.swo" "*~" "*.bak" "*.backup" "*.orig"

# Nettoyage S√âCURIS√â des fichiers de build (seulement les dossiers build)
print_section "Nettoyage S√âCURIS√â des fichiers de build"
secure_clean "Fichiers de build" "build" "dist" "*.egg-info" "*.egg"

# Nettoyage S√âCURIS√â des fichiers de logs (seulement les logs temporaires)
print_section "Nettoyage S√âCURIS√â des fichiers de logs"
secure_clean "Fichiers de logs temporaires" "*.log.tmp" "*.out.tmp" "*.err.tmp" "debug.log.tmp" "error.log.tmp"

# Nettoyage S√âCURIS√â des fichiers corrompus (seulement les fichiers vraiment corrompus)
print_section "Nettoyage S√âCURIS√â des fichiers corrompus"
secure_clean "Fichiers corrompus" "*.f(f)" "*.corrupt" "*.broken"

# Nettoyage S√âCURIS√â des dossiers cache sp√©cifiques
print_section "Nettoyage S√âCURIS√â des dossiers cache sp√©cifiques"
secure_clean_cache_directories "Dossiers cache" ".pytest_cache" ".mypy_cache" ".ruff_cache" ".coverage" "htmlcov" ".tox" ".cache" "build" "dist" "*.egg-info" "__pycache__"

# Nettoyage S√âCURIS√â des caract√®res null des fichiers Python (seulement les fichiers non importants)
print_section "Nettoyage S√âCURIS√â des caract√®res null"
if [ "$DRY_RUN_MODE" = true ]; then
    echo -e "${YELLOW}   [DRY-RUN] Recherche de fichiers avec caract√®res null${NC}"
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        if is_important_file "$file"; then
            echo -e "${YELLOW}   [DRY-RUN] PROT√âG√â (avec caract√®res null): $file${NC}"
        else
            echo -e "${YELLOW}   [DRY-RUN] Fichier avec caract√®res null: $file${NC}"
        fi
    done
else
    find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./venv/*" -not -path "./archive/*" -not -path "./node_modules/*" -exec grep -l $'\x00' {} \; 2>/dev/null | while read file; do
        if [ -f "$file" ]; then
            if is_important_file "$file"; then
                print_warning "PROT√âG√â (avec caract√®res null): $file"
            else
                tr -d '\000' < "$file" > "$file.tmp" 2>/dev/null && mv "$file.tmp" "$file" 2>/dev/null
                print_success "Nettoy√©: $file"
                CLEANED_COUNT=$((CLEANED_COUNT + 1))
            fi
        fi
    done
fi

# Nettoyage S√âCURIS√â des fichiers de configuration temporaires (seulement les fichiers .tmp)
print_section "Nettoyage S√âCURIS√â des fichiers de configuration temporaires"
secure_clean "Fichiers de configuration temporaires" "*.cfg.tmp" "*.ini.tmp" "*.yaml.tmp" "*.yml.tmp" "*.json.tmp"

# Nettoyage S√âCURIS√â des fichiers de documentation temporaires (seulement les fichiers .tmp)
print_section "Nettoyage S√âCURIS√â des fichiers de documentation temporaires"
secure_clean "Fichiers de documentation temporaires" "*.md.tmp" "*.rst.tmp" "*.txt.tmp" "docs/_build" "docs/build"

# Nettoyage S√âCURIS√â des fichiers de IDE/√©diteurs (seulement les fichiers .tmp)
print_section "Nettoyage S√âCURIS√â des fichiers d'√©diteurs"
secure_clean "Fichiers d'√©diteurs" ".vscode/settings.json.tmp" ".idea/workspace.xml.tmp" "*.sublime-*" ".editorconfig.tmp"

# Affichage du r√©sum√©
print_summary 
#!/usr/bin/env python3
"""
ğŸ§ª TESTS COMPLETS - SECURITY MODULE
===================================
Tests complets pour amÃ©liorer la couverture du module security.py.
"""

import os
import tempfile
from pathlib import Path
from unittest.mock import Mock, mock_open, patch

import pytest

# Import du module Ã  tester
from athalia_core.security import security_audit_project


class TestSecurityComprehensive:
    """Tests complets pour le module security"""
    
    def setup_method(self):
        """Configuration avant chaque test"""
        self.temp_dir = tempfile.mkdtemp()
        self.project_dir = Path(self.temp_dir) / "test_project"
        self.project_dir.mkdir(exist_ok=True)
    
    def teardown_method(self):
        """Nettoyage aprÃ¨s chaque test"""
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_security_audit_project_clean_project(self):
        """Test d'audit de sÃ©curitÃ© sur un projet propre"""
        # CrÃ©er un fichier Python propre
        clean_file = self.project_dir / "clean.py"
        clean_file.write_text("""
def safe_function():
    return "safe"
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert 'f' in result
        assert 'issues' in result
        assert 'score' in result
        assert result['f'] is True  # Projet propre
        assert len(result['issues']) == 0
        assert result['score'] == 100
    
    def test_security_audit_project_with_password(self):
        """Test d'audit avec mot de passe en clair"""
        # CrÃ©er un fichier avec mot de passe en clair
        password_file = self.project_dir / "config.py"
        password_file.write_text("""
password = "secret123"
api_key = "sk-1234567890abcdef"
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False  # Projet avec problÃ¨mes
        assert len(result['issues']) >= 1
        assert result['score'] < 100
        
        # VÃ©rifier que les problÃ¨mes ont Ã©tÃ© dÃ©tectÃ©s
        issues_text = '\n'.join(result['issues'])
        assert "Mot de passe en clair" in issues_text or "ClÃ© API trouvÃ©e" in issues_text
    
    def test_security_audit_project_with_api_key(self):
        """Test d'audit avec clÃ© API"""
        # CrÃ©er un fichier avec clÃ© API
        api_file = self.project_dir / "api.py"
        api_file.write_text("""
api_key = "sk-1234567890abcdef"
secret = "sk-abcdef1234567890"
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
        assert result['score'] < 100
        
        # VÃ©rifier que les clÃ©s API ont Ã©tÃ© dÃ©tectÃ©es
        issues_text = '\n'.join(result['issues'])
        assert "ClÃ© API trouvÃ©e" in issues_text
    
    def test_security_audit_project_with_os_system(self):
        """Test d'audit avec appel systÃ¨me"""
        # CrÃ©er un fichier avec appel systÃ¨me
        system_file = self.project_dir / "dangerous.py"
        system_file.write_text("""
import os
os.system("rm -rf /")
os.system("ls")
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
        assert result['score'] < 100
        
        # VÃ©rifier que les appels systÃ¨me ont Ã©tÃ© dÃ©tectÃ©s
        issues_text = '\n'.join(result['issues'])
        assert "Appel systÃ¨me potentiellement dangereux" in issues_text
    
    def test_security_audit_project_multiple_issues(self):
        """Test d'audit avec plusieurs problÃ¨mes"""
        # CrÃ©er plusieurs fichiers avec problÃ¨mes
        file1 = self.project_dir / "config.py"
        file1.write_text('password = "secret"')
        
        file2 = self.project_dir / "api.py"
        file2.write_text('api_key = "sk-1234567890"')
        
        file3 = self.project_dir / "dangerous.py"
        file3.write_text('os.system("ls")')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 3
        assert result['score'] < 100
        
        # VÃ©rifier le calcul du score
        expected_score = max(0, 100 - 20 * len(result['issues']))
        assert result['score'] == expected_score
    
    def test_security_audit_project_with_f_files(self):
        """Test d'audit avec fichiers .f(f"""
        # CrÃ©er un fichier .f(f avec problÃ¨me
        f_file = self.project_dir / "config.f(f"
        f_file.write_text('password = "secret"')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
    
    def test_security_audit_project_file_read_error(self):
        """Test d'audit avec erreur de lecture de fichier"""
        # CrÃ©er un fichier qui ne peut pas Ãªtre lu
        unreadable_file = self.project_dir / "unreadable.py"
        unreadable_file.write_text("test")
        
        # Mock pour simuler une erreur de lecture
        result = None
        with patch('builtins.open', side_effect=Exception("Permission denied")):
            # Le test doit gÃ©rer l'exception
            try:
                result = security_audit_project(str(self.project_dir))
                # Si on arrive ici, le test passe
                assert result is not None
            except Exception:
                # Si une exception est levÃ©e, c'est aussi acceptable
                pass
        
        # VÃ©rifications - seulement si result a Ã©tÃ© dÃ©fini
        if result is not None:
            assert isinstance(result, dict)
            assert 'issues' in result
            # L'erreur de lecture devrait Ãªtre dans les issues
            issues_text = '\n'.join(result['issues'])
            assert "Erreur lecture" in issues_text
    
    def test_security_audit_project_empty_directory(self):
        """Test d'audit sur un rÃ©pertoire vide"""
        # ExÃ©cuter l'audit sur un rÃ©pertoire vide
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is True  # RÃ©pertoire vide = propre
        assert len(result['issues']) == 0
        assert result['score'] == 100
    
    def test_security_audit_project_ignores_non_python_files(self):
        """Test que l'audit ignore les fichiers non Python"""
        # CrÃ©er des fichiers non Python avec des problÃ¨mes
        txt_file = self.project_dir / "config.txt"
        txt_file.write_text('password = "secret"')
        
        json_file = self.project_dir / "config.json"
        json_file.write_text('{"password": "secret"}')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications - les fichiers non Python ne devraient pas Ãªtre dÃ©tectÃ©s
        assert isinstance(result, dict)
        assert result['f'] is True  # Aucun problÃ¨me dans les fichiers Python
        assert len(result['issues']) == 0
        assert result['score'] == 100
    
    def test_security_audit_project_case_insensitive(self):
        """Test que l'audit est insensible Ã  la casse"""
        # CrÃ©er un fichier avec des problÃ¨mes en majuscules
        case_file = self.project_dir / "config.py"
        case_file.write_text("""
PASSWORD = "secret"
API_KEY = "sk-1234567890"
OS.SYSTEM("ls")
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
    
    def test_security_audit_project_creates_audit_file(self):
        """Test que l'audit crÃ©e le fichier de rapport"""
        # CrÃ©er un fichier avec problÃ¨me
        problem_file = self.project_dir / "config.py"
        problem_file.write_text('password = "secret"')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifier que le fichier d'audit a Ã©tÃ© crÃ©Ã©
        audit_file = self.project_dir / "security_audit.txt"
        assert audit_file.exists()
        
        # VÃ©rifier le contenu du fichier d'audit
        audit_content = audit_file.read_text()
        assert "Mot de passe en clair" in audit_content
    
    def test_security_audit_project_score_calculation(self):
        """Test du calcul du score de sÃ©curitÃ©"""
        # CrÃ©er plusieurs fichiers avec problÃ¨mes pour tester le calcul
        for i in range(5):
            problem_file = self.project_dir / f"config_{i}.py"
            problem_file.write_text('password = "secret"')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 5
        
        # Le score devrait Ãªtre calculÃ© : max(0, 100 - 20 * nombre_issues)
        expected_score = max(0, 100 - 20 * len(result['issues']))
        assert result['score'] == expected_score
    
    def test_security_audit_project_with_subdirectories(self):
        """Test d'audit avec sous-rÃ©pertoires"""
        # CrÃ©er une structure avec sous-rÃ©pertoires
        subdir = self.project_dir / "subdir"
        subdir.mkdir()
        
        problem_file = subdir / "config.py"
        problem_file.write_text('password = "secret"')
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
    
    def test_security_audit_project_complex_patterns(self):
        """Test d'audit avec des patterns complexes"""
        # CrÃ©er un fichier avec des patterns complexes
        complex_file = self.project_dir / "complex.py"
        complex_file.write_text("""
# DiffÃ©rentes variantes de mots de passe
password = "secret"
PASSWORD = "secret"
user_password = "secret"
db_password = "secret"

# DiffÃ©rentes variantes de clÃ©s API
api_key = "sk-1234567890abcdef"
API_KEY = "sk-abcdef1234567890"
secret_key = "sk-1234567890abcdef"

# DiffÃ©rentes variantes d'appels systÃ¨me
os.system("ls")
OS.SYSTEM("rm -rf /")
system_call = os.system
""")
        
        # ExÃ©cuter l'audit
        result = security_audit_project(str(self.project_dir))
        
        # VÃ©rifications
        assert isinstance(result, dict)
        assert result['f'] is False
        assert len(result['issues']) >= 1
        
        # VÃ©rifier que diffÃ©rents types de problÃ¨mes ont Ã©tÃ© dÃ©tectÃ©s
        issues_text = '\n'.join(result['issues'])
        assert "Mot de passe en clair" in issues_text or "ClÃ© API trouvÃ©e" in issues_text or "Appel systÃ¨me" in issues_text


if __name__ == "__main__":
    pytest.main([__file__, "-v"]) 